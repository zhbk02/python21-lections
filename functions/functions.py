"========================== Функции ====================="
# функции - именованный блок кода который может принимать арументы и возвращать результат

def my_sum(a, b):
    return a + b

res = my_sum(5, 4)
print(res) # 9

"==========================Параметры==========================="
# параметры - локальные переменные внутри функции значение которыи мы задаем прри вызове функции (переменные которые мы указали внутри скобочек при создании функции (когда писали def))
# сначала определяем обязательные, потом по дефолту, потом *, и в конце **
#  2.3 kwargs



"=========================Аргументы==================="
# аргументы - значения которые мы передаем параметрам при вызове функции
# сначала всегда передаются позиционные потом именованные 


"======================Виды аргументов================"
# 1. позиционные
# 2. именованные (ключ=значение)

def sum_or_add_10(a, b=10):
    # b - параметр с дефолтом 10
    return a + b
    

    print(sum_or_add_10(2, 3)) # 5
    print(sum_or_add_10)(5)    # 10
    print(sum_or_add_10(2, 9))  # 11
    print(sum_or_add_10(15))    # 25


def func(*args, **kwargs):
    # args - tuple в который нам приходят все аргументы, которые были переданы через запятую (кроме обязательных и по дефолту)
    # kwargs - dict,  в который нам приходят все аргументыб которые были переданы ввиде ключ=значение (кроме именованных)
    print(args, kwargs)

func(1,2,3,4,(5,67,8,9,0),{"a":5}, a=3, b=5)

def func2(a, b=5, *c, **d)
print("a -", a)
print("b -", b)
print("c -", c)
print("d -", d)
func2 () - TypeError 

func2(10)

# a - 10
# b - 5
# c - ()
# d - {}

func2(10, 20)
# a = 10
# b = 20
# c (10, 20)
# d - {}

func2(10, 20, 30, 40)
# a = 10
# b = 20
# c (30, 40)
# d - {}

func2(10, 20, 30, 40, a=5, b=6)
# TypeError
#  потому что в переменную а позиционнуо мы передали 10, а именованную 5

func2(10,20, 30, 40, c=5, d=6)
# a = 10
# b = 20
# c (30, 40)
# d - {"c":5, "d":6}





"===========звездочка============ * ====================="
# * - знак умножения 
# * - распаковка

list_ = [1, 2, 3, 4, 5]
list1 = [*list_] # распаковываем значения в списке в новый список (в новую ячейку памяти) (укорачивает цикл for)

dict_ = {"a":3, "b":6}
dict2 = {**dict_} # распоковка пар (ключ:значение)
# распаковка пары в словаре в новый список






database = {
    "Бекзат": "скала",
    "Эртай": "пароль",
    "Оомат": "Кыргызстан",
    "Имран": "12345",
    "Жийде": "return",
    "Манас": "Маке",
    "Арафат": "54321",
    "Элжаз": "парол",
    "Гулсана": "312",
    "Эркайым": "Айдин",
    "Бекназ": "Арёль",
    "Эдиль": "ьлорап",
    "Айгул": "май",
    "Закир": "@@@",
    "Бегайым": "makers",
    "Мырзайым": "Bootcamp2221",
    "Даниэл": "covid19",
    "Жибек": "1404",
    "Айгерим":"moon02",
    "Калысбек": "стол",
    "Ырыс": "suuuuuuuuiiiiiiiiiiii",
    "Айканыш": "qwerty",
    "Арген": "11172332",
    "Нурмухамед": "Не верный",
    "Бектур": "0101",
    "Алан": "душу питона",
    "Жаангер": "ох блин",
    "Богдан": "Кудайберген",
    "Айгерим": "синий маркер",
    "Настя": "Python21"
}

def login(username):
    for i in range(3):
        if username in database:
            password = input("Введите пароль: ")
            if password == database[username]:
                print("Success")
                break
            else:
                print("Incorrect password")
        else:
            print("Incorrect username")
            break

login(username="Мырзайым")


def translate(string):
    eng = "qwertyuiop[]asdfghjkl;'zxcvbnm,."
    ru = "йцукенгшщзхъфывапролджэячсмитьбю"    
    if string[0] in eng:
        dictionary = str.maketrans(eng, ru)
    else:
        dictionary = str.maketrans(ru, eng)
    return string.translate(dictionary)

print(translate(input("Введите слово: ")))

